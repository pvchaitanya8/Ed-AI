{
    "questions": [
      {
        "question": "What is Insertion Sort?",
        "options": [
          "A sorting algorithm that builds a sorted list one element at a time",
          "A divide and conquer sorting algorithm",
          "An algorithm that sorts by swapping adjacent elements",
          "A recursive sorting algorithm"
        ],
        "answer": "A sorting algorithm that builds a sorted list one element at a time",
        "explanation": "Insertion Sort works by taking elements from an unsorted list and inserting them into their correct position in a sorted list, one at a time.",
        "incorrect_explanation": {
          "A divide and conquer sorting algorithm": "This describes algorithms like Merge Sort or Quick Sort, not Insertion Sort.",
          "An algorithm that sorts by swapping adjacent elements": "This is more descriptive of Bubble Sort.",
          "A recursive sorting algorithm": "Insertion Sort is primarily an iterative algorithm."
        }
      },
      {
        "question": "What is the time complexity of Insertion Sort in the worst case?",
        "options": [
          "O(n)",
          "O(n log n)",
          "O(n^2)",
          "O(1)"
        ],
        "answer": "O(n^2)",
        "explanation": "In the worst case, Insertion Sort requires O(n^2) comparisons and shifts when sorting a list that is in reverse order.",
        "incorrect_explanation": {
          "O(n)": "This is the best case time complexity, occurring when the list is already sorted.",
          "O(n log n)": "This time complexity is characteristic of more efficient sorting algorithms like Merge Sort or Quick Sort.",
          "O(1)": "This would indicate constant time complexity, which does not apply to sorting algorithms."
        }
      },
      {
        "question": "What is the space complexity of Insertion Sort?",
        "options": [
          "O(n)",
          "O(log n)",
          "O(1)",
          "O(n^2)"
        ],
        "answer": "O(1)",
        "explanation": "Insertion Sort is an in-place sorting algorithm, meaning it requires only a constant amount of additional space.",
        "incorrect_explanation": {
          "O(n)": "This would imply the algorithm requires additional space proportional to the input size, which is not the case for Insertion Sort.",
          "O(log n)": "This space complexity is associated with recursive algorithms, not Insertion Sort.",
          "O(n^2)": "This would suggest that the algorithm needs a quadratic amount of space, which is incorrect."
        }
      },
      {
        "question": "In which scenario is Insertion Sort most efficient?",
        "options": [
          "When the dataset is large",
          "When the dataset is small",
          "When the dataset is in reverse order",
          "When the dataset is randomly ordered"
        ],
        "answer": "When the dataset is small",
        "explanation": "Insertion Sort is particularly efficient for small datasets (generally less than 20 elements) because of its simplicity and low overhead.",
        "incorrect_explanation": {
          "When the dataset is large": "Larger datasets require more comparisons and shifts, making Insertion Sort less efficient.",
          "When the dataset is in reverse order": "This scenario results in the worst-case time complexity for Insertion Sort.",
          "When the dataset is randomly ordered": "While it can handle random datasets, it is less efficient compared to other algorithms for large lists."
        }
      },
      {
        "question": "What does it mean for an algorithm to be 'stable'?",
        "options": [
          "The algorithm runs in constant time",
          "The algorithm does not change the relative order of equal elements",
          "The algorithm can sort in both ascending and descending order",
          "The algorithm is efficient"
        ],
        "answer": "The algorithm does not change the relative order of equal elements",
        "explanation": "A stable sorting algorithm maintains the original order of records with equal keys, which is crucial in certain applications.",
        "incorrect_explanation": {
          "The algorithm runs in constant time": "Stability is not related to time complexity.",
          "The algorithm can sort in both ascending and descending order": "Stability refers specifically to equal elements, not sorting direction.",
          "The algorithm is efficient": "Efficiency relates to time complexity, not stability."
        }
      },
      {
        "question": "How does Insertion Sort adapt to partially sorted lists?",
        "options": [
          "It performs more comparisons",
          "It performs fewer comparisons and shifts",
          "It becomes inefficient",
          "It requires more memory"
        ],
        "answer": "It performs fewer comparisons and shifts",
        "explanation": "Insertion Sort is adaptive, meaning it makes fewer comparisons and shifts when the list is partially sorted, leading to better performance.",
        "incorrect_explanation": {
          "It performs more comparisons": "This is incorrect; it reduces the number of comparisons for partially sorted lists.",
          "It becomes inefficient": "Insertion Sort can be quite efficient for partially sorted data.",
          "It requires more memory": "It maintains O(1) space complexity regardless of the list's state."
        }
      },
      {
        "question": "What element does Insertion Sort start with in the sorted part?",
        "options": [
          "The smallest element",
          "The largest element",
          "The first element",
          "The last element"
        ],
        "answer": "The first element",
        "explanation": "The algorithm starts with the first element as the initial sorted part, and the rest are considered unsorted.",
        "incorrect_explanation": {
          "The smallest element": "While the smallest element may end up first, the first element is simply the starting point.",
          "The largest element": "This would not be true as the largest element is in the unsorted part initially.",
          "The last element": "The last element starts in the unsorted part."
        }
      },
      {
        "question": "What is the key role of the 'key' variable in the implementation of Insertion Sort?",
        "options": [
          "To store the largest element",
          "To store the smallest element",
          "To store the current element being inserted into the sorted part",
          "To store the number of comparisons made"
        ],
        "answer": "To store the current element being inserted into the sorted part",
        "explanation": "The 'key' variable holds the value of the current element from the unsorted part that is being positioned in the sorted part.",
        "incorrect_explanation": {
          "To store the largest element": "This is incorrect; the 'key' may not be the largest element in the unsorted part.",
          "To store the smallest element": "Similarly, the 'key' is not necessarily the smallest element.",
          "To store the number of comparisons made": "This is unrelated to the function of the 'key' variable."
        }
      },
      {
        "question": "What happens to elements in the sorted part that are larger than the 'key'?",
        "options": [
          "They remain in place",
          "They are shifted to the left",
          "They are shifted to the right",
          "They are removed from the sorted part"
        ],
        "answer": "They are shifted to the right",
        "explanation": "Elements in the sorted part that are greater than 'key' are shifted one position to the right to make room for 'key'.",
        "incorrect_explanation": {
          "They remain in place": "This would not allow 'key' to be positioned correctly.",
          "They are shifted to the left": "This would not maintain the correct order.",
          "They are removed from the sorted part": "This is incorrect as they need to remain in the sorted part."
        }
      },
      {
        "question": "Which of the following is true about Insertion Sort's average case time complexity?",
        "options": [
          "It is O(n log n)",
          "It is O(n^2)",
          "It is O(n)",
          "It is O(n^3)"
        ],
        "answer": "It is O(n^2)",
        "explanation": "On average, Insertion Sort will require O(n^2) comparisons and shifts for randomly ordered lists.",
        "incorrect_explanation": {
          "It is O(n log n)": "This is the time complexity of more efficient sorting algorithms like Merge Sort.",
          "It is O(n)": "This would suggest a linear time complexity, which is not applicable in average cases.",
          "It is O(n^3)": "This complexity is not relevant to Insertion Sort."
        }
      },
      {
        "question": "In what type of applications is Insertion Sort most commonly used?",
        "options": [
          "Large scale data processing",
          "Sorting small datasets",
          "Database indexing",
          "Machine learning"
        ],
        "answer": "Sorting small datasets",
        "explanation": "Insertion Sort is particularly effective for sorting small datasets due to its simplicity and efficiency.",
        "incorrect_explanation": {
          "Large scale data processing": "This is typically handled by more advanced algorithms.",
          "Database indexing": "Insertion Sort is not typically used in this context.",
          "Machine learning": "While sorting is involved in preprocessing, Insertion Sort is not a common algorithm here."
        }
      },
      {
        "question": "Which statement best describes the performance of Insertion Sort on a nearly sorted list?",
        "options": [
          "It is inefficient",
          "It performs well",
          "It has high time complexity",
          "It does not work"
        ],
        "answer": "It performs well",
        "explanation": "Insertion Sort is adaptive and performs efficiently on nearly sorted lists, minimizing comparisons and shifts.",
        "incorrect_explanation": {
          "It is inefficient": "This is incorrect; it can be very efficient on nearly sorted data.",
          "It has high time complexity": "The time complexity can be low for nearly sorted lists.",
          "It does not work": "Insertion Sort will still work on any list."
        }
      },
      {
        "question": "What is the first step in the process of Insertion Sort?",
        "options": [
          "Sort the entire list",
          "Start with the first element as sorted",
          "Take the largest element",
          "Find the smallest element"
        ],
        "answer": "Start with the first element as sorted",
        "explanation": "The algorithm begins by considering the first element as the only sorted element.",
        "incorrect_explanation": {
          "Sort the entire list": "This is not how Insertion Sort operates; it sorts incrementally.",
          "Take the largest element": "The largest element is not the starting point.",
          "Find the smallest element": "Finding the smallest element is not part of the initial step."
        }
      },
      {
        "question": "How many times does the inner loop run in the worst case for Insertion Sort?",
        "options": [
          "n",
          "n-1",
          "n^2",
          "0"
        ],
        "answer": "n^2",
        "explanation": "In the worst case, the inner loop runs approximately n(n-1)/2 times, leading to O(n^2) performance.",
        "incorrect_explanation": {
          "n": "This would indicate that the inner loop runs linearly, which is not the case in the worst scenario.",
          "n-1": "While close, it does not account for all iterations across the entire array.",
          "0": "This would indicate no iterations, which is incorrect."
        }
      },
      {
        "question": "Which of the following is NOT an advantage of Insertion Sort?",
        "options": [
          "Simple to implement",
          "Efficient for small datasets",
          "Works well on large datasets",
          "Stable sorting algorithm"
        ],
        "answer": "Works well on large datasets",
        "explanation": "Insertion Sort is not efficient for large datasets compared to more advanced sorting algorithms.",
        "incorrect_explanation": {
          "Simple to implement": "This is indeed an advantage of Insertion Sort.",
          "Efficient for small datasets": "This is a recognized benefit of the algorithm.",
          "Stable sorting algorithm": "Insertion Sort is stable, which is an advantage."
        }
      },
      {
        "question": "In the provided code, what does the line 'arr[j + 1] = key' do?",
        "options": [
          "It initializes the key variable",
          "It places the key in its correct position",
          "It swaps elements",
          "It ends the sorting process"
        ],
        "answer": "It places the key in its correct position",
        "explanation": "This line assigns the 'key' value to its appropriate index in the sorted part of the array.",
        "incorrect_explanation": {
          "It initializes the key variable": "The key variable is initialized earlier in the code.",
          "It swaps elements": "The line is not for swapping; it places the 'key' at the correct index.",
          "It ends the sorting process": "The sorting process continues after this line."
        }
      }
    ]
  }
  